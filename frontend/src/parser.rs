use pest_derive::Parser;

use crate::ast;
use crate::ast::AstNode;
use pest::Parser;

#[derive(Parser)]
#[grammar = "src/parser.pest"]
pub struct BblParser;

// The Rule enum is automatically generated by pest_derive

use crate::ast::Expr;
use crate::ast::IfExpr;
use crate::ast::IntegerLiteral;
use crate::ast::ListExpr;
use crate::ast::PrintExpr;
use crate::ast::Program;
use crate::ast::StringLiteral;
use crate::ast::TypedIdentifier;
use pest::iterators::Pair;

fn build_ast_from_expr(pair: Pair<Rule>) -> Option<AstNode> {
    match pair.as_rule() {
        Rule::program => {
            let nodes = pair
                .into_inner()
                .filter_map(|pair| build_ast_from_expr(pair)?.Expr())
                .collect::<Vec<Expr>>();
            Some(AstNode::Program(Program { expressions: nodes }))
        }
        Rule::expression => build_ast_from_expr(pair.into_inner().next()?),
        Rule::typed_identifier => {
            let mut inner_nodes = pair.into_inner().collect::<Vec<Pair<Rule>>>();
            assert!(inner_nodes.len() == 2);
            let mut type_of_id = build_ast_from_expr(inner_nodes.pop()?)?.Type()?;
            let mut id = build_ast_from_expr(inner_nodes.pop()?)?
                .Expr()?
                .Identifier()?;
            Some(AstNode::TypedIdentifier(TypedIdentifier {
                value: id,
                associated_type: type_of_id,
            }))
        }
        Rule::type_annotation => {
            let p_clone = pair.clone();
            let mut inner = pair.into_inner();
            let type_name = p_clone.as_str().to_string();
            if (inner.len() >= 1) {
                let inner_type = build_ast_from_expr(inner.next()?)?.Type()?;
                if type_name.starts_with("list") {
                    Some(AstNode::Type(ast::Type::List(Box::new(inner_type))))
                } else if type_name.starts_with("tuple") {
                    Some(AstNode::Type(ast::Type::Tuple(Box::new(inner_type))))
                } else {
                    None
                }
            } else {
                match type_name.as_str() {
                    "int" => Some(AstNode::Type(ast::Type::Int)),
                    "float" => Some(AstNode::Type(ast::Type::Float)),
                    "string" => Some(AstNode::Type(ast::Type::String)),
                    _ => None,
                }
            }
        }
        Rule::identifier => Some(AstNode::Expr(Expr::Identifier(ast::Identifier {
            value: pair.as_str().to_string(),
        }))),
        Rule::assignment => {
            let mut inner_rules = pair.into_inner().collect::<Vec<Pair<Rule>>>();
            // typed identifier and expression
            assert!(inner_rules.len() == 3);

            let expr = build_ast_from_expr(inner_rules.pop()?)?.Expr();
            let identifier = build_ast_from_expr(inner_rules.pop()?)?.TypedIdentifier();
            let var_val = inner_rules.pop()?;

            Some(AstNode::Expr(Expr::AssignmentExpr(ast::AssignmentExpr {
                target: identifier?,
                value: Box::new(expr?),
                const_var: (var_val.as_str() == "val"),
            })))
        }

        Rule::print_expr => {
            let expr = build_ast_from_expr(pair.into_inner().next()?)?.Expr();
            let print_expr = PrintExpr::new(expr?);
            Some(AstNode::Expr(Expr::PrintExpr(print_expr)))
        }
        Rule::integer => {
            let int_value = pair.as_str().parse::<i128>().unwrap();
            Some(AstNode::Expr(Expr::Integer(IntegerLiteral::new(int_value))))
        }
        Rule::list_expr => {
            let mut inner = pair.into_inner();
            let mut elements = Vec::new();
            while let Some(element) = inner.next() {
                let element = build_ast_from_expr(element)?;
                elements.push(element.Expr()?);
            }
            Some(AstNode::Expr(Expr::ListExpr(ListExpr { elems: elements })))
        }
        Rule::string_literal => {
            let string_value = pair.as_str().trim_matches('"').to_string();
            Some(AstNode::Expr(Expr::String(ast::StringLiteral {
                value: string_value,
            })))
        }
        Rule::float => {
            let float_value = pair.as_str().parse::<f64>().unwrap();
            Some(AstNode::Expr(Expr::Float(ast::FloatLiteral {
                value: float_value,
            })))
        }
        Rule::function_def => {
            let inner_rules = pair.into_inner().collect::<Vec<Pair<Rule>>>();
            let name = build_ast_from_expr(inner_rules.get(0)?.clone())?
                .Expr()?
                .Identifier()?;
            let args = inner_rules[1..inner_rules.len() - 1]
                .iter()
                .filter_map(|rule| build_ast_from_expr(rule.clone())?.TypedIdentifier())
                .collect::<Vec<TypedIdentifier>>();
            let body = build_ast_from_expr(inner_rules.last()?.clone())?.VecExpr()?;
            Some(AstNode::Expr(Expr::FunctionDef(ast::FunctionDef {
                name,
                args,
                body,
            })))
        }
        Rule::return_expr => {
            let expr = build_ast_from_expr(pair.into_inner().next()?)?.Expr()?;
            Some(AstNode::Expr(Expr::ReturnExpr(ast::ReturnExpr {
                value: Box::new(expr),
            })))
        }
        Rule::bin_op => {
            let mut inner_rules = pair.into_inner().collect::<Vec<Pair<Rule>>>();
            let right = build_ast_from_expr(inner_rules.pop()?)?.Expr();
            let op = inner_rules.pop()?.as_str().to_string();
            let left = build_ast_from_expr(inner_rules.pop()?)?.Expr();
            Some(AstNode::Expr(Expr::BinOp(ast::BinOpExpr {
                left: Box::new(left?),
                op,
                right: Box::new(right?),
            })))
        }
        Rule::block => {
            let vec_rules = pair
                .into_inner()
                .filter_map(|rule| build_ast_from_expr(rule)?.Expr())
                .collect::<Vec<Expr>>();
            Some(AstNode::VecExpr(vec_rules))
        }
        Rule::if_expr => {
            let inner_rules = pair.into_inner().collect::<Vec<Pair<Rule>>>();
            let cond = build_ast_from_expr(inner_rules.get(0)?.clone())?.Expr()?;
            let body = build_ast_from_expr(inner_rules.get(1)?.clone())?.VecExpr()?;

            let else_expr = if inner_rules.len() == 3 {
                Some(build_ast_from_expr(inner_rules.get(2)?.clone())?.VecExpr()?)
            } else {
                None
            };

            Some(AstNode::Expr(Expr::IfExpr(IfExpr::new(
                cond, body, else_expr,
            ))))
        }
        _ => None,
    }
}

pub fn parse_program(input: &str) -> Result<Box<AstNode>, String> {
    match BblParser::parse(Rule::program, input) {
        Ok(parsed) => {
            for pair in parsed {
                let node = match build_ast_from_expr(pair) {
                    Some(n) => n,
                    None => return Err("Failed to build AST from expression".to_string()),
                };
                return Ok(Box::new(node));
            }
        }
        Err(e) => {
            return Err(e.to_string());
        }
    }
    return Err("Failed to parse program".to_string());
}
